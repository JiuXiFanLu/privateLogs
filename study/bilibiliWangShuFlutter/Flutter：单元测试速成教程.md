字幕

字幕

00:00

hello

00:00

大家好

00:00

我是王叔

00:01

我们又见面啦

00:02

那这期视频呢我想带大家初步的去了解一下

00:05

flutter这个里面的widget testing

00:06

就是单元测试中关于怎样测试你的widget

00:09

大家可以看到呢

00:11

我这边已经又打开了fter

00:12

新建项目时候自带的一个demo小程序

00:14

就是一个很简单的计数器

00:15

然后呢我们同时可以看到

00:17

其实每次新建项目的时候

00:18

它都会自动帮我们建立一个test文件夹

00:20

在下面呢

00:21

他也帮我们写好了一个widget test

00:23

所以我们今天这期视频呢

00:24

就先带大家简单的解释一下这边的代码

00:27

然后呢我们再试着自己写一些其他的测试

00:29

看一下它的一些其他功能

00:31

首先呢在开始之前我要简单说一下这个test啊

00:34

所有的单元测试都是放在这个test文件夹

00:36

并且要以下划线test.dart结尾

00:39

这样当你去做ccd pipeline的时候呢

00:41

你就直接可以在这边输butter test

00:43

然后呢这样呢它会自动跑这个test文件夹下

00:45

所有以下划线test.dt结尾的文件

00:48

如果不是以这个结尾的话

00:50

它就不会跑好

00:52

说完这个之后呢

00:53

我们就非常简单的来看一下啊

00:54

首先我们怎么样手动跑一下这单元测试

00:56

对吧啊

00:57

可能有的啊

00:58

有的同学可能不太清楚

00:59

就是在这啊选上一个target device

01:01

然后这边呢就选上我们平常这边不是命吗

01:04

我们把它选成这边的test

01:05

可以选上这test

01:06

然后点个开始就可以了

01:07

还有一种方法呢啊

01:09

就是你不动

01:09

这直接在这边

01:10

就是你这个test文件呢直接在这边啊

01:13

有一个小按钮对吧

01:14

如果你是安卓studio或者tj的话

01:16

应该是有的

01:16

然后直接点这个run test

01:18

这样就可以去跑这个unit test跑下

01:21

并且看到了我们的结果是成功的

01:22

这边打了一个小勾

01:23

表示我们的结果是成功的

01:25

好

01:25

我们来简单看一下他对我们这个测试

01:27

就是测这个up他做了什么

01:29

首先呢这是test wages

01:30

这边是随便起了个名字

01:31

比如说我们这边就随便给他改名叫my tests啊

01:34

这就是随便起了个名字

01:35

然后呢首先他做第一件事情是test test pump budget

01:39

然后呢把my app直接传给他

01:41

这pump vision呢通常来说只需要叫一次

01:43

就有点类似于grun up

01:45

run up

01:45

也是把my up传给他

01:47

这边呢也是同样的

01:48

把任何一个位置传给pump位置

01:49

当然你可以写成这样的run up对吧

01:51

因为你导入了main文件夹

01:52

就run up my up这个位置

01:54

当然你也可以自己写任何其他的位置

01:56

比如说你直接写pa啊

01:57

这样也是可以的

01:58

好

01:59

现在呢把一个位置当做组件树的根部和pp过去

02:02

接着呢我们就可以看到它呢

02:04

去看一下我们的counter是不是从零开始的啊

02:06

就是说我们新运行这个项目的时候呢

02:08

我们项目应该这个样子

02:09

对不对

02:09

所以呢他要去看一下有没有find.text 0啊

02:13

找一找这个屏幕上有没有零这么一个text组件

02:15

find.text啊

02:17

一会儿我会来详细的说一下find的其他方法

02:19

目前我们可以看到放一点text

02:21

会帮我们找一个呃里面的文本内容为零的

02:24

这么一个text组件或者是text field的组件

02:27

或者是什么其他的rich text类似的那种tt的组件

02:30

然后呢我们找到它对吧

02:31

这样呢我们这个finder呢就找到了

02:33

找到之后呢

02:33

我们expect期待值

02:35

这边呢是实际的值

02:36

左边是实际值

02:37

右边是期待值

02:38

这我相信大家应该是就算没写过这种widget test

02:41

可能写过普通的单元测试吧

02:42

所以对这expect之类的东西

02:44

应该不是很陌生对吧

02:45

所以我就不会花太多时间讲这个了

02:47

所以呢这边是f find one位置找到一个好

02:50

然后同时呢他再去试一下全屏幕上有没有一啊

02:53

没有一对吧

02:54

所以finds nothing一个都没有找到

02:56

这边我们可以点开看一下这个final wwage finer

02:59

其实就是用了这个find vision matter

03:01

传了一个最小数为一

03:02

最大数为一

03:03

也就是说至少找到一个

03:04

最多找到一个同样的啊

03:06

零呢就是没有找到嘛

03:08

还有一个类似的叫做find at least and wages

03:11

比如说至少找到了五个

03:13

那他就会传给他一个最小数值五

03:15

最大数now

03:16

就是随便你多少克都可以啊

03:18

就类似于这样的

03:18

有一些自己帮你做好的一些东西

03:20

find at least envision

03:21

或者是这边直接有final version对吧

03:23

就必须找到三个

03:25

比如说那他就会找matter呢

03:26

至少三个至多也是三个

03:28

就这么一个道理好

03:29

那他呢就是要写fine nothing对吧

03:31

我不能在这个屏幕上找到

03:32

找到现在文本内容为一的这么一个text组件

03:36

或者是text field的组件

03:37

或者是rich text组件类似的组件

03:39

接着呢我们再去find by icon啊

03:41

通过find.by icon的方法找到一个icons

03:44

点add就是这个添加按钮对吧

03:46

找到了这么一个icon之后呢

03:49

他用了test.tab

03:50

就是点击这个icon好点了一下

03:52

点了一下之后呢

03:53

大家知道我们这个flash程序呢on top会发生什么呢

03:56

会increment counter对吧

03:57

然后increment counter这边呢是counter加加

03:59

但是有个set state

04:00

set state呢

04:01

我们之前做过不少视频都讲过了对吧

04:03

需要在下一次build的时候才能看出反应

04:05

csc只不过是一个标脏的行为对吧

04:07

所以呢等到下一次bill的时候

04:08

我们才能看到屏幕上的变化呀

04:10

所以呢在这里我们tag完了之后呢

04:11

他测试的时候它的屏幕并没有build

04:14

所以呢我们就需要再叫一次pump啊

04:16

注意刚开始是pump widget

04:17

把一个组件放到组件输入的根部

04:19

这边呢是用pump表示呢

04:21

往后啊多pump出来一针啊

04:23

pump就有点像是打气筒

04:24

或者是压出来一个东西对吧

04:26

你可以想象你把打气筒往下按了一下

04:28

然后啪一下打出了一针啊

04:29

这是在top出一针

04:31

那也就是说我们的屏幕就会刷新一下

04:33

刷新了之后呢

04:33

因为我们awaight对吧

04:35

我们等他胖p完了之后呢

04:36

我们现在再来找找零呢

04:37

就不应该能找到了对吧

04:39

因为刚才的零已经变成一了嘛

04:40

这时候我再去找一呢

04:41

就可以find one widget

04:43

所以呢这整个的测试都是ok的

04:44

刚刚也跑过了

04:45

是可以过的

04:46

那这个例子呢当然比较简单

04:48

这是一个非常简单的概述一下

04:50

让大家找一找这个with it test的感觉

04:51

接下来呢我们先来介绍从fd开始介绍好吧

04:55

finder就finder

04:57

finder呢就是帮你去寻找某一个widget啊

04:59

当然我们这个屏幕嘛pop过来对吧

05:01

一整个把app都给他了

05:02

所以这里面呢啊都是由各种各样的位置做成的

05:04

因为毕竟flutter everything is a vision对吧

05:06

以切皆为组件

05:07

所以总是有很多很多组件

05:09

所以这边的这个find啊

05:10

首先点text

05:10

刚才已经讲了两遍了

05:11

就是找到包含这个文本的组件

05:13

但是呢他找到了呢是什么组件呢

05:15

刚说了是text组件

05:16

包括text rich对吧

05:17

或者rich text组件

05:19

或者editable text组件

05:21

也就是说他找到的文本

05:22

并不是普通的其他文本对吧

05:24

比如说这个呢

05:24

这是这是什么

05:25

这是up bar对吧

05:26

我们来看一下

05:27

哎我们来看一下这caffle里面有个up bar

05:29

然后呢up bar这边呢有个text对吧

05:32

所以说当我们传给他fdm home配置这个

05:34

把这个字符串传给他的时候

05:36

他找到的是text组件

05:37

而不是up bar组件

05:39

因为它只能找text rich text

05:40

editor text之类的组件好

05:43

那类似的方法呢我们来看一下啊

05:44

find还有什么

05:45

比如说find呢除了text还可以把icon

05:47

刚刚有看到有例子对吧

05:49

这边要find.by icon

05:50

icon呢就是必须要找到那个icon组件好

05:53

那接下来呢还有其他的

05:55

例如这边有啊啊

05:57

image

05:57

我记得应该是image

05:58

image就是找到image组件对吧

06:00

你告诉他你那个图片应该长什么样子

06:03

接下来我们来看一下找一些其他组件的方法

06:05

比如说我想找这个up bar对吧

06:07

那我刚刚可以说把type啊

06:09

注意不是by widget啊

06:11

我一会来讲by widget

06:12

by type呢就可以告诉他我们要找什么类型的组件

06:15

我们要找个up bar组件

06:16

对不对

06:16

所以呢是把这个up bar类型的组件告诉他

06:18

所以呢他就能找到一个up

06:20

把我们先把这个下面的内容都可就是这样好

06:23

那比如说我们找这个far呢

06:25

我们就可以expect能不能找到一个阿bar

06:27

应该是能的对吧

06:28

所以呢是find one位置好

06:31

我们来运行一下

06:35

嗯没有问题能找到对吧

06:36

如果我们把它换成fight nothing呢

06:38

能不能找不到f8 应该是不对的

06:40

就会错误对吧好

06:42

这边呢就fail了对吧

06:43

比如nl min

06:44

然后这边会有最底下会有reason

06:45

one was fun banners expected对吧

06:47

他找到了一个

06:48

但是我们说没有

06:49

所以我们的这个单元测试写错了

06:51

不是程序写错了是吧

06:52

好啊

06:53

find by type是up by

06:54

那可能有同学刚刚看了find widget

06:56

会觉得那up bar不是一个widget吗

06:58

对不对啊

06:59

其实不是的一个widget呢就是一个特定的位置啊

07:02

up bar呢是一种类型的widget

07:03

对不对啊

07:04

什么意思呢

07:05

就是说比如说我自己去debug啊

07:07

比如说阿b等于阿宝好

07:09

我new一个阿宝出来

07:11

这个呢是我的阿贝的名字对吧

07:13

这个变量名我就可以把这个传给他

07:15

所以呢final version是可以这样找的啊

07:17

但是这样的话应该是找不到的

07:18

因为我们毕竟是我们之前的pump

07:21

就是run up对吧

07:22

我们run up run是my app

07:23

my app里面有没有这个up bar

07:25

没有

07:26

他有他的阿布

07:27

对不对

07:27

那是他的阿布

07:28

我们的阿贝尔是我自己

07:29

在这自己又随便new出来一个阿布

07:31

所以这个阿布当然找不到了

07:33

所以发这样的这个单元测试呢是可以过的好

07:36

所以呢这是by vision啊

07:37

刚才看了by type啊

07:38

就是by type

07:38

那by ty可能就有同学会说了

07:40

那by type肯定是

07:41

那你如果有好多个怎么办

07:42

比如说我把text这个type不就是很不方便吗

07:45

因为我这至少有三个text

07:46

对不对啊

07:47

那确实是这样的

07:48

所以说你找tt的时候呢

07:49

你可以通过他的这个文字来找

07:51

然后找icon的时候呢

07:52

你可以通过icon上面的内容来找对吧

07:54

icon data来找

07:55

你总是能想到自己的办法

07:56

但是实在想不到办法呢

07:57

我们还有一个万能的办法

07:59

就是通过t我们这边呢可以传给他一个t

08:01

对不对

08:02

传给他个key之后呢

08:03

我们这边是不是就可以通过by key来找啊

08:05

啊通过白t来找呢

08:06

显然我们这边需要传一个key给他

08:08

但是呢你可能会惊讶于诶

08:09

我这个是main

08:10

就是我up中的东西

08:11

我这儿的key怎么才能传到单元测试这边来呢

08:14

对不对

08:15

我是不是比如说这个key呢

08:16

我是不是要在这比如说定义的global key啊

08:18

比如说key等于global key对吧

08:20

我new了个global key

08:21

然后把这个key呢传给他

08:24

那我在单元测试

08:25

那怎么才能获得这个题

08:27

对吧啊

08:28

确实是这样的

08:28

如果想要获得热key呢

08:29

确实是不太方便啊

08:30

不是说没有办法

08:31

确实说不太方便

08:32

对不对

08:33

不过好在我们一般也不需要通过这种方法

08:35

因为我们在key系列教程里面也讲过

08:37

其实除了global key之外呢

08:39

我们还有objea key

08:40

马里奥t

08:41

还有unique key

08:43

对吧啊

08:44

关于他们不同的区别

08:45

大家如果不熟悉

08:46

确实是可以再回顾一下我们key那系列教程

08:48

目前呢我们看来啊global key刚看了

08:50

要在顶上定义一下

08:51

不太方便

08:52

uni key呢它只和自己相等

08:53

肯定不好用

08:54

object key和y6 key呢

08:55

它区别在于object必须要是同一个内存指针

08:58

对不对

08:58

所以说理所当然的

08:59

value key呢就变成了我们这类测试的首选

09:01

因为value key呢只和这边的value一致就可以了

09:05

比如说我叫上阿富对吧

09:06

上传给它一个86k r8 呢

09:08

那于是我在这边呢

09:09

我是不是可以传统一个86k

09:10

然后呢只要给它的这个value是一样的

09:13

那它呢就等于是同一个p

09:14

于是呢这样呢我们是应该能找到一个的

09:16

所以我这边的unit test说nothing是错误的嗯

09:20

可以看到你是错误的对吧

09:22

因为那是应该能找到的

09:24

one was found

09:25

but not expected对吧

09:26

应该是能找到一个

09:27

也就是说翻key呢

09:28

通过value key这种比较方便的方式

09:30

当然肯定会有同学会说啊

09:32

我这样为了写个测试

09:33

我还得在这加个value key

09:34

我又不打算给他弄key对吧

09:36

确实是这样的

09:36

那我们要怎么才能找到这个伴呢

09:38

当然刚才说了by type

09:39

因为这里面总共只有一个up b

09:41

我们假设你有很多个

09:42

我们怎样才能找到啊

09:43

我们这个shorter demo home配置的这个up bar呢

09:46

刚刚说点tt不行

09:47

因为找到text对不对啊

09:49

怎么办呢

09:49

其实也是很有办法的

09:50

比如说我们这还有个方法叫做widget with text

09:53

顾名思义就是说我们要找一个widget with text好

09:57

他via type就是刚才说的up far

09:59

up bar是一种type对吧

10:00

但是呢这和我们刚刚看到的直接by type不同对吧

10:03

by type呢可以找f2

10:04

但是呢你并不知道是哪一个up bar

10:06

而这边呢我这with text呢我们找up bar

10:08

并且我们要求它的里面就是他的descendant啊

10:12

它的子集里面呢

10:13

总的来说呢是要有包有这么一个text

10:15

所以呢这边我们就可以给它传入这个fter demo

10:18

home page

10:18

这样我们就可以通过这个with text来找到它

10:21

我来简单的演示一下啊

10:24

这样的应该是能找到两个的

10:26

所以放在n v这两个对吧

10:28

找所有的tb了

10:29

一切的tab这个类型会找到两个

10:31

但是呢这边我们说widget with text

10:33

up bar类型

10:34

并且里面必须要写有water demo同配置字样的

10:39

那么就只能找到一个

10:41

也就是find one

10:42

好把它写出两行代码

10:44

有点长了是吧

10:45

同时呢如果我把这东西写错

10:47

比如说这时候他就应该是找不到了

10:50

所以是finds nothing

10:52

任何的ip类型有两个这样字样的呢

10:55

阿b有一个这样字样的app

10:57

二呢一个都没有

10:58

我们来运行一下

11:02

可以看到刚刚那个阿布出现了是吧

11:04

我加在这个column这多加了个r b

11:06

所以它就出现在这了

11:07

不要觉得奇怪哈

11:08

行我看到我们test past啊

11:10

所以说这样呢我们这三个都是正确的

11:12

这就是通过find widget with text的方法来加一个条件啊

11:16

去找到我们这个某一个位置的啊

11:18

并且要求他有一些字样

11:20

也就是说他的descendant里面呢

11:22

一定要有这么一个text组件

11:23

或者是rich text或者是text file组件

11:27

那这个呢其实还有一个更加generic版本啊

11:30

更加通用的版本就是了

11:31

直接叫descended

11:32

可想而知嘛

11:33

因为刚才的widget with text

11:35

一定要求我们是在找阿b

11:37

并且要求它里面包有一个text

11:39

但如果我们要找某一个东西

11:40

但是包邮的那个东西呢不是text或者icon或者image

11:44

那就不能用wit with text with icon with image

11:47

就可以通过使用点第三点的方法呢啊

11:49

来这样来做它啊

11:51

不过因为有这个video with text嗯

11:53

这种方法存在的

11:54

一般这样去查找descending的啊

11:56

不是很常见

11:57

但是反过来去找他的上级组件

11:58

也就是找他的ancestor呢

12:00

还是一个比较常见的操作

12:01

所以我在这边呢来举个例子

12:03

比如说我想找这个color color里面有阿bar text什么的

12:06

再比如说我这里面还有个circle coc运行一下

12:09

假如我是要找这么一个包含着circular progress

12:13

我就可以通过widget.ancestor

12:16

好

12:17

我们来看一下as的方法

12:18

还有一个finder of和一个finder matching好

12:21

首先呢是off对吧

12:22

那off呢也是个finder

12:24

我们先来找谁呢

12:25

assister of谁

12:26

ancestor of这个circle progress indication

12:29

我们要找他的祖先对吧

12:30

所以呢sistor of five five type

12:33

circular project indicate

12:34

我整个程序就一个

12:35

所以我可以放心的是

12:36

用百type一定能找到那一个

12:38

然后呢这时候我要去找到这一个东西

12:40

它的祖先它的祖先是个什么类型啊

12:44

可以看到marching是吧

12:45

它的祖先也是一个by type

12:48

是一个column类型

12:50

没错吧

12:52

你看一下这个ancestor啊

12:53

他要求这个off是require的啊

12:55

他这个off和machine两个是有名字的

12:57

这是of matter

12:59

这样啊

13:00

所以呢我们就可以好谁呢啊

13:01

这个circular progress in nett

13:03

找到他的祖先

13:04

他的上级不是有很多东西吗

13:05

他的上级有column center scarf

13:07

什么都是对吧

13:08

但是我们就是要找color

13:09

这样我们就可以找到一个color

13:11

好

13:11

我们再来运行一下

13:12

正好写的是fight one wit

13:13

应该是能找到

13:14

同样的

13:14

我们能不能找到一个scaffle

13:16

肯定也是能找到的对吧

13:17

因为他是ancestor嘛

13:19

不是他的parts啊

13:20

不是他的负极

13:21

而是他的上级

13:22

就是它的任何组件都是可以的

13:24

我们就找到了这个scarf

13:25

其实我们平常在flutter中用的这个cafff

13:28

点of context里面那个off是差不多一样的意思对吧

13:31

就是上面的任何组先级都可以给你找到好

13:35

那就是assister

13:36

那同样的刚才没有举例的这个descent也是一样的

13:38

用法

13:39

一个一个machine啊

13:40

那这样的话那就应该是找不到

13:41

因为我们没有在circle

13:45

而是反着的一个关系

13:46

对不对

13:46

所以呢我们就倒过来嗯

13:49

好我把它倒过来了

13:50

我们再来运行一下

13:51

这样呢就应该能找到了

13:52

这样的连起来就是find.descend of scarf

13:55

我们在scaffold的下面找什么呢

14:01

于是呢

14:04

好

14:04

我们简单总结一下

14:05

首先是这个finder

14:06

我们通过find点方法

14:08

那我们可以找到text啊

14:10

还有bicon by key by widget by type

14:12

甚至我们还可以使用什么widget with text

14:15

wit with icon

14:15

widget with image对吧

14:17

然后呢我们还可以通过这个descended和ancestor

14:20

这两种方法呢

14:20

在主件数中穿梭

14:22

那找到了这个位置之后呢

14:23

我们就可以对它进行一些测试对吧

14:26

那首先最常见的也是最简单的测试呢

14:28

刚刚已经看了

14:29

我们可以直接expect

14:30

有没有找到

14:31

找到一个

14:32

找到两个没有找到还是找到了多少个

14:34

这个呢通常就已经是一个挺不错的判断了

14:37

那其实这样做呢可能还不太够

14:39

在某些情况下呢

14:39

你可能想要更复杂的判断

14:41

所以我们再来简单看一下

14:42

还有些什么其他常见的测试方法

14:44

比如说啊我回到这儿来

14:46

我把这个先删掉

14:48

我们就做简单一点的说

14:49

这找一个方式logo

14:50

我最喜欢用fter logo了对吧

14:52

然后呢上面的阿贝也删掉

14:54

感觉就是怪怪的

14:55

好在外面的column呢

14:56

我给它加一个container

14:57

上了颜色是orange

15:00

这样我们就有了一个橙色的container对吧

15:02

我们呢现在想来测试一下

15:04

flutter logo外面的这个靠拢

15:05

不理它

15:06

外面的这个container是不是橙色的

15:08

我们来测一下啊

15:10

fashilogo外面的container是不是橙色的

15:12

怎么测呢

15:13

我们先把这些给删掉

15:15

首先呢我们要先来找到这个container对吧

15:18

找到container呢

15:18

刚才有办法就是可以通过ancestor

15:20

找到flutter logo的ancestor

15:22

然后是一个container

15:23

对不对

15:23

所以我们可以先find by type

15:25

找到这个flutter logo

15:27

对不对

15:27

所以呢我们的态度是一个fer logo好

15:30

找到了flush logo呢

15:31

我们可以给他存下来

15:32

比如说叫做flutter logo

15:34

放的叫logo finder

15:36

然后呢我们还想找到外面的container

15:38

所以呢我们配角final啊

15:40

computer final等于find the ancestor

15:43

好好谁呢

15:44

off on the logo finder是吧

15:46

那指什么呢

15:47

那是一个container

15:48

所以呢我们还需要再找一个container finder对吧

15:50

所以还是find点按by type

15:54

这样呢我们就找到了一个里面含有logo finder

15:58

也就是flutter logo的这么一个container对吧

16:01

好找到这个container之后呢

16:03

我们先来看一下这个container

16:04

它比如说我们首先啊刚刚说了

16:06

我们先expect能找到一个了吧

16:08

所以呢我们要看我们刚刚找到这个container

16:10

finder是不是能找到一个

16:12

所以来简单运行一下

16:14

好发现它是嗯test past对吧

16:18

所以测试通过了确实能找到一个

16:20

我们接下来来看一下它

16:21

是不是我们说的这个颜色

16:23

也就是orange好

16:24

那我们怎么去看它的颜色呢

16:26

这时候就可以用test

16:28

我们之前也用过test test.pump widget

16:30

这边呢我们可以接种test

16:31

点位点位置呢就可以去把一个finder啊

16:36

就是我们找到这个container finder的

16:37

把它变成一个widget

16:38

那变成什么widget呢

16:40

他并不知道对吧

16:41

我们可以告诉他

16:42

通过泛型告诉我们想找的是一个container get

16:46

这样我们就得到了他的widget之后呢

16:48

我们就可以调用container应该有的方法

16:50

比如说container有color

16:51

我们就可以让他把这color可以打印出来了

16:54

我们先打印出来看一眼

17:00

这边可以看到material color

17:02

是确实打印出来了一种颜色

17:03

我不太确定这个是不是colors.orange

17:06

所以呢我们还是通过expect的方法expect啊

17:09

就是你找到了这个color

17:12

它应该是colors.orange对吧

17:15

我把它切成两哈

17:16

把这print可以删掉

17:18

再运行下

17:19

这样的测试呢应该是可以过的

17:21

好没错

17:22

测试过了再回来

17:23

如果我们呢故意把这个改一下

17:26

我们再来运行一下测试

17:28

看它测试应该就过不了了啊

17:31

没问题

17:32

测试已经fail了对吧好

17:34

我们接着再举个例子

17:35

比如说呢我这container给他设置个height啊

17:37

比如说它的height是200好吧

17:39

然后呢我们这个你按下这个按钮之后

17:41

不是会增加吗

17:42

增加这个counter它自带的功能对吧

17:43

我们呢就把这个container一会变成200

17:46

一会变成400啊

17:47

我来简单的通过这个counter是不是一本

17:49

是不是偶数来确定它是200还是400

17:52

就是呢我们的效果就是你按一下它

17:54

它就会这么动一下对吧

17:56

我们怎么去测试它这个现在的高度呢

17:59

嗯没有同学可能会想吧

18:01

那我们来试试我们这个container能不能得到

18:03

它的he是没有hit方法的

18:06

可以看到对吧

18:06

这边是没有heat方法的

18:08

这其实在我们讲key那系列教程里面

18:10

有讲到过对吧

18:11

稍微提了一下

18:11

因为这个size啊它并不是跟着wa走的

18:14

而是跟着他的render object

18:16

大家也知道这个布局的时候呢

18:17

你这个size啊并不是真正出现在屏幕上的size啊

18:20

因为你真正的size呢

18:21

通常还需要去考虑上级的尺寸约束

18:24

以及你下一级的这个child的size来决定的

18:26

对不对

18:27

所以说他其实不算是这个widget

18:29

也就是你的蓝图的一部分啊

18:31

那有什么办法我们能获得它的size呢

18:32

那当然有了

18:33

我们可以通过test.get size方法来直接获得

18:36

其实看过我们key系列那个global key的两种用法

18:39

那期视频的人应该知道

18:40

然后我们其实也是用过这个get size方法对吧

18:43

那是在render object里面用的get size方法

18:45

就可以得到它的size

18:47

那同样的我们来看一下

18:48

也是需要一个finder嘛对吧

18:49

所以finder呢我们还是需要刚才讲的这个container

18:52

finder

18:52

通过ancestor好不容易找到这container

18:54

再来复用一下container

18:56

finder得到它的size之后呢

18:58

我们就可以去他size

19:00

我们需要他的height size

19:01

有with和heat

19:02

我们就可以expect它的高度了

19:03

也就是200

19:04

再来运行一下

19:07

因为这个程序刚开始运行的时候呢

19:08

应该是200吧

19:09

对我来从头开始运行

19:11

刚开始运行的时候是零

19:12

因为他这边这个top位置呢

19:14

其实就相当于我们的命函数

19:15

刚才说了对吧

19:16

所以这边其实是从头开始运行的

19:18

也也就是说在他的这个测试视角中的

19:20

这个计数器目前的值是零

19:22

所以说它其实就应该是200了

19:24

其实我这边按成了一

19:25

跟这个测试没有关系嘛

19:26

对吧

19:26

我测试重新跑一遍

19:27

它还是刚开始是零

19:29

所以呢这边测试是200是可以过的好

19:31

接着呢我们还可以去啊点击一下这个按钮对吧

19:35

那怎么去点击这个按钮呢

19:36

其实刚刚是这边是有例子的啊

19:38

这边呢就是await test.hub

19:40

然后之后呢他用了一个pump对吧

19:42

不要忘记要pump多出一帧才有这个效果

19:45

所以呢我们也一样的啊

19:46

test.tab find

19:47

把icon的方法找到这个icon

19:49

他找的到底是这个floating action button呢

19:52

还是找到这个icon

19:53

其实找的是这个icon

19:55

对不对

19:55

找到icon之后呢

19:56

他对他进行了tab

19:58

点击了这个icon的位置啊

20:00

其实也没有关系的

20:01

因为点击了这个坐标的这个位置呢

20:03

他正好是这个floating action button啊

20:05

悬浮按钮所在的位置

20:06

所以他这么点下去之后呢

20:07

也是可以有同样的效果

20:08

并不需要真的去找到昨天action button这一个元素

20:11

但如果你愿意来找的话

20:13

也非常容易对吧

20:14

你可以甚至可以直接摆pad

20:15

然后通过这个锁定牙齿

20:17

button也是同样可以找到

20:18

然后呢好不管怎么样

20:20

你找到了之后呢

20:20

你pop了一下对吧

20:22

就是倒了下一帧

20:23

好

20:23

我们再从头开始运行啊

20:24

我跟着他走一遍

20:25

刚开始是零

20:26

然后我们确定它的高度呢

20:27

这个橙色是橙色的container

20:29

且它的高度为200

20:31

接着呢

20:31

我们让他点击一下唯一的一个floating action button

20:34

啊

20:34

应该不会点错对吧

20:35

点击完之后呢

20:36

我们让他pump

20:36

就是等了下一帧

20:37

也就是发生了这样的事情

20:39

所以这时候呢我们再去看这个expect 200

20:41

这时候还能不能过啊

20:43

应该测试就会出错了

20:45

因为这时候他应该变成了400对吧

20:47

我们先跑一下错误的情况好

20:48

看到出错了

20:49

我们再改成400

20:50

再跑一下

20:51

正确的情况

20:53

可以看到test past啊

20:54

没有任何的问题

20:55

这样呢我们就完成了这么一个unit test

20:57

好再简单总结一下啊

20:59

我们可以通过test.widget方法

21:01

传入一个通用类型之后呢

21:03

我们可以获取widget中的不少参数

21:06

通过这个点get size方法呢

21:07

我们可以得到它render object里面的这个真正的size

21:10

所以呢我们可以获取它的height和wi

21:12

来对它进行一个测量

21:13

我们可以通过test.tab方法和test.pump方法好

21:17

先tab模拟某一个finder

21:19

某一个finder找到的位置对吧

21:20

我们去点击它一下之后

21:22

你在pump出现新的一帧

21:24

这是这样的情况

21:25

然后接下来呢我们就可以pub完了之后呢

21:27

看到了这边有了改动啊

21:28

我们再去新的expect对吧

21:32

好

21:33

接下来呢我们再看这边这个container组件呢

21:35

如果我们把它换成一个animated container

21:37

好

21:38

让它变成一个显示动画组件

21:39

这时候呢我们再给他传上一个direction

21:41

比如说一秒钟的时长

21:42

这时候呢我们再按下这个按钮

21:45

它就会啊

21:46

要通过一秒钟的时间来完成这个渐变的效果

21:50

这时候呢我们再回到我们的单元测试这儿呢

21:53

我们这边呢test.pop

21:54

就是我们点完这个按钮之后啊

21:56

我们直接pump了一帧一帧呢

21:58

它是实现不了这个动画效果的

21:59

你们要一秒钟时间嘛

22:01

那就是每每16ms一帧吧

22:03

那就需要大约60多针才可以完成对吧

22:05

所以我们胖子一下子是不够的啊

22:07

那怎么办呢

22:08

嗯而在这之前让我们先来确认一下啊

22:11

我们看一下这边container找一下啊

22:14

这container

22:14

因为我已经把它改成了一个animated container

22:17

local finder

22:18

container finder

22:18

我们已经不太需要这些代码

22:20

不过把这改成一个

22:21

那你也可以搞太大

22:22

这样呢我们是在flutter logo外层对吧

22:25

ancestor找一个imated container

22:28

然后我们找到animated container

22:30

把这个color的就给删掉了啊

22:32

不太需要

22:32

然后我们这个200 400tab pp好

22:36

我们来运行一下我们的unit test啊

22:37

应该是不会通过的

22:39

我们刚刚说的这边呢是指pop的

22:41

一帧一帧是不够的对吧

22:42

可以看出他说啊想要400

22:45

但实际上才是200

22:46

因为我们只有一针嘛

22:47

他刚开始都画对吧

22:48

那我们怎么办呢

22:49

比如说呢这边我们可以有一个啊pop有pop frames

22:53

这可能是呃如果直接看这边的话

22:55

感觉pop frames是最接近我们想要的效果

22:58

让他多压几帧嘛

22:59

看一下啊

23:00

performs它需要一个target

23:01

这边要注意的是

23:02

它的target的是要求一个widget

23:04

而不是一个type

23:05

也不是一个finder

23:06

什么意思呢

23:07

就是说它不是要放上这么简单的一个

23:09

imated container

23:10

这个type在这

23:11

因为那肯定有很多个嘛

23:12

那也不是要一个finder

23:14

就是content finder

23:15

我们找到了这一个啊

23:16

他是真的要一个位置

23:17

所以我们一般有两种办法

23:19

第一种办法呢就是通过前面看到的tester.widget

23:22

把一个finder给它cast成一个widget

23:25

或者更方便的是

23:26

如果你在这个单元测试这有什么new widget

23:28

你也可以直接给它起名字

23:30

变成变量来直接使用

23:31

比如说在这边

23:32

我们不是一开始压了一个或者my app

23:34

我可以给这个my app起个名字

23:36

因为它就是一个位置对吧

23:37

它不是一个type

23:38

这样的my app是一个type

23:40

这样的new出来的一个my app对吧

23:43

new出来的一个my app呢其实是一个位置

23:45

所以说呢我们也可以给它起个名字

23:47

比如说这样啊

23:48

这到我的wig是一个constant my app对吧好

23:51

那就是说我们能pop出这个w w是一个my app

23:55

是一个constant

23:55

但是一个widget

23:56

所以呢在这边呢我就可以pump frames告诉他

23:58

我要pop这个my app其实就是全屏对吧

24:01

因为有时候你想对着一个地方进行刷新

24:04

比如说你有一个circular progress nor

24:06

你只想对着那一小片区域刷新

24:07

就可以对着那一块区域的做这个pop friends好

24:11

然后我们要刷多久的啊

24:12

不我们刷一秒钟够不够的啊

24:14

因为我们这边的动画呢就是一秒钟的对吧

24:16

我们来看一下一秒钟够不够啊

24:19

应该是不够的嗯

24:21

看一下果然是不够的

24:22

嗯确实一秒钟到了之后呢

24:24

他是刚好没有到对吧

24:25

因为我们是一秒钟的时长

24:27

一秒钟的时长

24:28

top出来之后呢

24:29

整整一秒钟

24:30

它最后会差一针

24:31

我们只需要一秒钟零一点点就可以了

24:32

比如说一秒钟加1ms

24:34

也就是1001ms

24:36

这样的就可以通过了

24:37

好没有问题

24:40

通过了对吧

24:40

所以说我们这个用pm frames

24:42

对着其中的一个widget

24:43

也就是我这边呢是对着把app做全屏幕的

24:46

你也可以的

24:47

如果你有条件的话

24:48

你也可以对着这个container

24:49

animated container单独做这样的pp

24:51

然后这边pop的时长呢

24:52

就是比你的动画时间稍微长一点点

24:55

就可以通过了

24:56

不过呢其实这边有个更简单的办法

24:58

就是它有另一个函数啊

24:59

test有函数叫做pop and settle

25:02

用pupsettle这个方法呢

25:04

你就不需要给他出任何参数

25:06

就像类似于我们刚刚一开始不是用了pop吗

25:09

pom呢是压出一个frame对吧

25:11

一帧top settle呢就是说当你这边可能有动画对吧

25:14

动画呢它预习的时候呢

25:16

它会自动降下一帧

25:17

是不是

25:17

所以说花瓣settle呢就是压一针

25:19

然后呢自动检查有没有必要再压出下一针

25:22

如果有必要的话

25:23

那就一直压压到它没有下一帧位置

25:25

所以直接按pupsettle

25:27

就会让它自动把这个动画跑完

25:29

所以呢这样的测试呢应该也是能够通过的好

25:32

那关于这个呢我这边呢再稍微多讲一下啊

25:35

我们可以打开这个filter performance对吧

25:37

呃这边呢相信大家可能也不陌生

25:39

这边我们可以看到他的free per second

25:40

是不是他为什么这边没有显示的

25:43

可以看到他没有在刷新

25:44

是不是

25:44

是因为flush 1 t

25:45

其实是知道他现在没有必要刷新的

25:48

所以为了省电

25:48

也就是节约性能嘛

25:50

因为手机电池是有限的

25:51

对不对

25:52

为了节约性能

25:53

它就在你屏幕完全静止的时候呢

25:55

不会多压出其他的针

25:57

这是flutter引擎会帮你做的事情

25:59

那比如说我让它开始动画对吧

26:01

可以看到在动画的过程中呢

26:03

这边是不断的有新的针

26:04

然后再按一下

26:05

对不对

26:06

只有在有动画时候呢

26:08

这边才有动作

26:09

当然你如果比如说里头也算circular progress mac

26:11

让它一直转

26:12

那么就会一直有动画

26:14

所以呢flutter就一直需要去给你新的针对吧

26:16

所以呢这边也就自然而然会一直有这个

26:18

所以在这种情况下呢

26:20

其实永远都会有下一帧出现

26:21

所以呢pop settle呢啊就不可以使用了啊

26:24

我这边来再使用一下

26:25

可以看一下这个unit test

26:27

就会一直跑一直跑一直跑

26:28

因为他想要抛盘settle对吧

26:30

他想要先build一帧

26:31

然后看一下有没有成功啊

26:32

这也没有成功

26:33

是不是啊

26:34

应该是因为我们这个psettle pout啊

26:37

时间到了就是超时延时了啊

26:40

因为这边有个circular progress indicate的

26:42

导致这边一直在转

26:43

对吧好

26:44

我再把它删掉啊

26:45

这边没了

26:45

你看这边呢就停下来了

26:47

所以所谓的pom settle呢

26:48

你看这样呢是在pop

26:49

然后呢就settle

26:50

因为我们当没有circle progressic的时候

26:53

没有动画的时候

26:54

它自己就会settle

26:55

这就是pop settle的意义

26:56

刚才有看到他有这个time out对吧

26:58

拍帽子呢如果没记错的话

27:00

是有一个参数的啊

27:01

应该叫什么

27:01

就叫duration time out啊

27:04

看见没有

27:04

他是用方括号打的

27:05

所以它不是命名参数啊

27:06

一开始的第一个是duration

27:08

然后是face

27:08

然后最后一个time out对吧

27:10

所以说啊你如果愿意的话

27:12

你可以把这个time out呢传给他

27:13

这样呢这个旁白settle呢就可以跑更长的时间好

27:16

这就是pop settle和刚刚讲的这个pop frame啊

27:20

对着其中一个位置刷很多针

27:22

以及一开始就看到了这个简单的pop

27:24

就是只压住一针好

27:27

接下来呢我们来讲一下交互

27:29

其实交互呢我们刚刚有看到啊

27:30

最简单的这个test.tab对吧

27:32

这边呢我们也是通过一个final

27:34

找到了一个floating action button啊

27:36

非常简单

27:36

然后呢test.tab.一下

27:38

他就进行了一次单机事件对吧

27:40

那类似的呢像tt tab这样类似的

27:43

我们还有其他的一些方法啊

27:44

我这边大家简单的举个例子

27:46

比如说呢我在这有个x field文本框

27:49

我想在文本框中输入一些内容啊

27:51

这是可以做到的

27:52

对吧啊

27:53

所以说我这边呢也可以通过test

27:55

我先把其他的这个测试给关掉吧

27:58

有点太长了

27:59

让他直接return下面的这些代码呢

28:01

就等于是啊停用了对吧好

28:04

那就是away啊

28:05

test.tab

28:06

这是单机flotr 10 mart

28:07

我想让它在我们的这个text field

28:10

里面输入一些东西啊

28:11

我们来看一下find by tag text field

28:14

因为我整个屏幕只有一个text field对吧

28:16

这样我会点击text field

28:18

那记完之后呢

28:19

我想在里面输入内容

28:20

我就可以通过enter text方法

28:22

他同样的需要找一个finder对吧

28:23

而我们这边呢find my type就已经找到了一个finder吧

28:26

找到了tt field

28:27

接着呢我们传一个stray给他

28:29

非常的简单

28:30

比如说我们传个stray

28:31

随便传一个王叔不秃好

28:33

然后呢他其实呢就爱玩了这个内容对吧

28:36

所以呢这时候我们可能需要用一个pop frame

28:40

刚才这个test.pop对吧

28:42

我们再去wa哈哈好

28:45

找到一个frame

28:46

画完frame之后呢

28:47

我们应该期待的结果就是

28:49

这个text field上面已经能找到v s

28:51

b t这样的字符串

28:53

所以呢我们也可以来测试了啊

28:55

我们是expect对吧

28:56

实际情况是我们来找一下

28:59

找到这个texture by tab的话

29:01

一定能找到一个texture对吧

29:02

刚才有看到text

29:03

就是我们来看一下能不能找到这个字样

29:06

the matter

29:07

我们是希望他能找到一个

29:08

所以是five one位置

29:11

下面的代码就不需要了

29:12

我们来看一下啊

29:13

这样的我们测试能不能过

29:17

好的测试过了对吧啊

29:18

确实是啊

29:19

完全没有问题

29:20

所以呢就是刚开始我们找到了一个text field

29:22

往里面说了这个字符串

29:24

接着呢

29:24

我们就能在屏幕上找到

29:26

包含这个字符串的这么一个啊tt field

29:28

那我们接下来呢再弄的稍微复杂一些

29:31

比如说我在这边呢来加一个clear按钮

29:33

把这个admate container删掉了

29:35

因为有了背景不是很好看是吧好吧

29:38

flogo改成一个elevated butter compressed

29:41

我们可以让他来清除

29:43

像icon换个花样

29:45

icon显lear

29:47

这样呢有这么一个按钮

29:50

点上它之后呢

29:50

我们希望它这边的文字呢就可以清除掉好吧

29:53

所以呢我们要这么做的话

29:55

我们需要用到controller的

29:56

所以我们在顶上定义一下

29:59

等于tx editing controller好

30:03

然后呢我们把这个controler的传给他

30:06

elevate butter

30:07

impressed controler

30:08

declare

30:09

对吧好

30:10

我们来试用一下这个程序

30:11

先随便输入点内容

30:12

然后按下这个按钮

30:13

它就清空了

30:14

所以呢这边呢我们也可以是expect find这个对吧

30:18

然后接下来呢我们让他去按一下按钮

30:20

test detab好

30:22

我们怎么样能找到这个按钮呢

30:23

我们可以把icon对不对啊

30:27

简单复习一下一开始学的知识对吧

30:29

然后这个icon呢就是icon.clear

30:32

就是打了一个叉

30:33

跟我们这边呢是用的一样的icon icon stclear

30:35

所以他就能找到这么一个icon

30:37

然后呢按一下这个按钮

30:38

然后接下来呢我们也可以再抄一下

30:40

这边的find one vision改成fnc对吧

30:43

就是因为你按了这个切除按钮嘛

30:45

之后呢就自然而然找不到了

30:48

运行一下

30:49

好的没有问题是吧

30:51

好接下来我们再来举个例子

30:52

我们来简单的看一下这个好滑动的操作吧

30:55

滑动的操作一般我们用什么方法呢

30:57

比如啊比如说我们就很简单

31:00

在这个啊这个输入框上面呢

31:02

我们允许它这样子从左到右这么划一下好吧

31:05

从左到右划一下呢

31:06

就啊出一个自动填空的那种感觉吧

31:09

所以我们来简单做一下这个功能

31:10

找到这个text field tech detect对吧

31:13

然后可以按horizontal drag and就是结束滑动

31:19

但是做这个简单的demo

31:20

我觉得也没有必要检测

31:23

我们都给它自动填充

31:24

那就是control.tt

31:26

整体比做hello world好

31:29

我们来试用一下这个功能啊

31:31

这样一滑就出现了hello

31:33

然后一点它就可以删掉

31:34

对吧啊

31:35

不管你一开始写的是什么

31:37

一滑就会给他替换成hello world

31:38

因为我确实爱的是替换嘛对吧

31:40

或者我不能替换吧

31:41

我把它改成一个家吧

31:44

这样就可以了吧

31:45

应该好

31:46

我们再来试验一下

31:48

试用一下这个功能

31:49

我先输a b c d

31:51

然后自动给我自动auto correct

31:53

成了这个

31:53

然后我一滑就后面加了个hello world

31:55

再一滑又加了个helloworld

31:57

可以吧

31:57

好那我们接下来呢就可以来这边来做测试了啊

32:00

test tab先找到它啊

32:02

其实顺便说一下

32:03

这个tab enter text之前不一定需要用它

32:06

这这是可有可无的

32:07

有些情况比如说你好多个txt的

32:09

或者是一些其他你搞focus搞得比较复杂

32:11

focus node比较复杂的情况下

32:13

可能需要先tab先点击

32:14

在其他情况下

32:15

绝大部分情况下enter text的是不需要先点击的

32:18

而且enter text之后呢应该是不需要pop的

32:21

我也不是特别确定啊

32:22

好像是不需要pop

32:23

那我后面克粒尔之后也没有需要pub对吧

32:25

所以我来预习一下啊

32:27

不让他先点击

32:28

也不用他pump看一下是不是还是能过啊

32:31

还是可以过的啊

32:32

就是这时候我们刚刚的猜测对吧

32:33

然后接下来呢我们再让它在里面再写上一个abc

32:39

写完abc之后呢

32:40

我们需要让它从左到右划一下对吧

32:43

也就是a b c

32:44

然后呢这样划一下

32:45

所以我们要让他写await test点啊

32:50

这个是drag

32:51

同样需要一个finder啊

32:52

也就是我们一直在找的这个find by type text field

32:56

接着呢需要传入一个offset

32:58

offset大家都很熟悉了对吧

32:59

我们让它比如说是从左到右滑

33:02

那么就是x的方向有个dx offset

33:04

比如说花200个逻辑像素啊

33:06

diy呢就是竖着的

33:07

这个垂直方向呢不需要有offset对吧

33:10

这样的就是稳稳的啊

33:11

从这个位置的稳稳的向右滑200的单位对吧

33:14

划完之后呢

33:16

转完之后呢

33:16

我们来看一下

33:17

再来去expect一下

33:19

因为我们这样子一拖动呢

33:20

是会出现一个hello world对吧

33:22

刚开始呢我们是输了a b c

33:23

前面这有clear

33:24

所以这边呢从这开始就是空白了

33:27

然后呢我们按了a b c让他划了一下

33:29

所以它效果应该是会出现这样的字对吧

33:33

所以我们expect能找到a b c hello world

33:37

我们希望它能找到一个位置来运行一下

33:40

看一下这边拖动完之后需不需要pump

33:43

好难过啊

33:44

说明是不需要pop的

33:46

这样的拖动完了之后呢

33:47

我们立刻就发现了里面的内容是a b c

33:49

hello world对吧

33:50

然后呢我们再按一下这个tab

33:52

看一下是不是就不太能找到这个a abc啊

33:56

这他find nothing

33:57

我们现在的要求里面的少是空的对吧

33:59

让我们再来运行一下好这样的就可以了

34:06

视频的最后呢

34:07

我们再来讲解一下一种稍微特殊一点的

34:09

但是在实战中也是很常用的

34:11

就是类似的滚动

34:12

因为它比较特殊一些

34:13

所以我就放到最后来讲啊

34:15

因为我要把这个例子呢都给换掉好

34:17

我们换成一个简单的list builder啊

34:19

然后呢这边呢item builder呢我们就让他非常的简单

34:22

我让他就turn一个list time好吧

34:25

然后title呢就写啊

34:27

item index加一

34:29

然后subtitle呢

34:31

当然这个需要一个text text

34:33

就是this is an item in the list

34:36

好吧

34:37

就随便写点内容运行过去好

34:39

这样呢这个item当然是无限多个对吧

34:41

比如说我给他一个item count啊

34:45

比如说我让他有20个吧

34:47

好我们再从头运行一下

34:48

这应该是20个了对吧好

34:50

总共只有20个组件啊

34:52

现在呢我们来看一下这个滚动啊

34:54

当然你可以说我可以用这个drag对吧

34:57

test 2点drag offset的方法呢

34:58

直接获得这个滚动

34:59

是不是啊

35:00

我们也可以先试一下

35:01

我们先来把这些都给删掉吧

35:03

我们直接开始真的从头开始写好

35:05

利用我们这个这期视频学到的所有知识呢

35:08

我们来开始从头开始写好吧

35:10

所以刚开始呢第一件事情啊

35:12

test vigets对吧

35:13

然后呢我们需要test.pump

35:15

需要把一个一般来讲呢是cost my up的

35:17

直接看不过去

35:18

就有点类似于run up对吧

35:20

接下来呢我们就可以去试验一下

35:22

看一下我们这个list view里面的item 1

35:24

是不是有正确的显示出来对吧

35:26

我们用最简单的方法find by type list view对吧

35:29

我们就找到了我的this view

35:30

看一下是什么问题啊

35:32

他不认识list view啊

35:33

是因为我们没有导入list view该在的包

35:35

比如说我们可以导入material包对吧

35:37

material包里面有list view吧

35:39

所以这样就有了view好

35:40

我们找到了view之后呢

35:42

我们可以看一下这里面有没有item一吧

35:45

比如说其实要是找item一的话

35:47

那我也不需要找less uid

35:48

我可以直接expect find a text

35:50

看一下有没有i乘一是否存在对吧

35:54

match呢

35:54

我们希望他找到一个位置

35:56

同样的item 0是否存在的啊

35:59

是不存在的对吧

36:00

我们希望它能find nothing

36:02

因为我们这个是从一开始1~20好吧

36:05

我们来运行一下

36:09

好的这样是没有问题的

36:12

而且在刚开始的比较后面的一项

36:14

比如说第18项是找不到的

36:16

因为这个屏幕呢没有那么大不对

36:18

所以呢我们要让他去找第18项

36:21

我们先错误的让他说find one为止

36:23

我看下他会不会报错

36:25

报错的话

36:26

那我们就把它调成fnc对吧

36:32

好这样呢我们的测试就可以过了

36:33

好接下来呢我们让它往下滚动一下

36:35

然后呢找到第18项好吧

36:38

那找到滚动的话呢

36:39

刚才我们看到的

36:40

我们可以用这个test.drag的方法对吧

36:43

那finder呢就是找到这个list view好

36:46

找到了cpu之后呢

36:47

我们抓个offset

36:48

这次是啊往下滚动对吧

36:50

其实是往上滚动

36:51

你看我鼠标现在点下去

36:53

然后呢是往上拖动它才是往下滚对吧

36:56

这个list啊

36:57

再看一下是我的鼠标线在中间点击它之后呢

37:00

我们是往上滚动才能出现出下面的内容对吧

37:04

所以呢我们这个diy呢应该是负的

37:05

比如说-500嗯

37:07

好出现了-500之后呢

37:09

就jug完之后当然需要await

37:11

它对吧

37:11

我们要等待它操作完这件事情之后呢

37:14

接下来呢我们来让他做一个test点哈

37:16

出一个新的一帧出来

37:18

好新的一帧出来之后呢

37:19

我们下面让他找什么呢

37:21

因为它滚动了一些嘛对吧

37:22

我也不知道它滚到哪里去了

37:23

但是这个第一个item应该是没有了对吧

37:26

所以呢我们让他去找第一个item

37:29

应该是fine版本

37:31

至于这几个item到底到哪了

37:34

我也不是很确定

37:35

但是可以确定的是

37:35

第一个item只要稍微滚一滚呢

37:37

应该还是没有了的啊

37:38

测试也过了对吧

37:40

所以说比如说我想让滚到地18项啊

37:42

然后18项这呢它有一个什么东西

37:45

比如说有个icon

37:46

比如说我们这边的index

37:47

这写一个if等于17

37:50

因为我们是index加一吗

37:51

这边对吧

37:52

那我们需要return一个lut logo啊

37:55

不是第17项

37:56

第18项呢变成了一个flash logo这种情况啊

37:59

那怎么办呢

38:00

我怎么样去测试这个呢

38:01

对吧啊

38:01

比如说我想让它拖到第19项出现的时候

38:04

我想看一下17项和这个logo是不是都能看得到

38:08

我应该过多少呢

38:09

是不是就比较麻烦

38:10

这时候呢我们就可以用到

38:11

这次我们视频介绍了最后一种方法了

38:13

就是我们pasta呢除了这个drag

38:15

比较简单的这种粗暴的drag之外

38:17

还有专门为this view之类的东西做了一个叫做scl

38:20

until visible

38:21

就是scuntil某一样东西变得visible

38:25

然后这个delta呢就是每一次scroll多少

38:27

就是比如说我让它一直scroll到这个item 19

38:30

变得可见为止

38:32

而且让他每一次呢是就score

38:34

每次滚动这个delta这么多

38:36

比如说我设成50啊

38:37

每次就滚这么点啊

38:39

每次就滚这点

38:39

每次滚这点对吧

38:41

然后呢每次滚完之后呢

38:42

他就检查它是否可见

38:43

或者把delta设成100

38:45

他就每次会多滚一点

38:46

然后就去检查

38:47

就这么一个意思好

38:48

那我们要发点人听什么visible呢

38:50

比如说我想让他item 19是变成visible对吧

38:52

那我们就可以说final test啊

38:55

item 19

38:56

我想让item 19元的visible一次滚动

38:58

比如说一次滚动100好

39:00

滚动到了之后呢

39:01

我pop一下呢

39:02

我需要他能看到iphone 19

39:04

那肯定是要能看到吗

39:05

因为既然你让我滚动到item 19 visible为止对吧

39:08

所以一定会看到item 19

39:10

同时呢当它变得可见的时候呢

39:11

我们要来能找到一个fluer logo

39:13

所以呢我们就可以把type swatch logo啊

39:17

希望他们也能找到一个对吧

39:19

同时呢17呢应该也能看到艾特17啊

39:24

这些呢希望它是都可以看到的

39:26

我们来测试一下

39:29

好的也是没有问题的

39:30

好最后呢我想再说一下这个scenvisible

39:33

这边呢他这个100就是刚刚说的每一次的delta

39:35

对吧

39:35

假如我把它ela改成一啊

39:37

他就会每次只滚动一点点

39:39

对不对啊

39:40

这样的情况下呢

39:41

我们这个测试还能通过吗

39:42

那肯定会有小伙伴觉得啊

39:44

你每次滚一和每次滚100应该无所谓吧

39:46

因为总的来说你一定会滚到这个19

39:49

然后当19出现的时候

39:50

它上面那个18和17呢

39:52

自然而然也一定会出现

39:53

对不对

39:53

好

39:54

我们来运行一下

39:54

看一下嗯

39:56

出乎意料的呢

39:57

他没有过对吧

39:58

这边出现了一个best day

39:59

no element

40:00

就说了他ren to visible

40:02

他怎么滚都没有滚到第19条

40:04

他认为这个list view是没有第19条的

40:07

因为我们这个函数或者说这个方法呢

40:09

它是叫scroll until visible对吧

40:11

会一直滚

40:12

那假如这个东西它确实不存在这个list里头啊

40:15

比如说呢和item 100

40:16

因为我们类似

40:17

总共只有20条

40:18

item 100确实不存在呢

40:19

我们也不能让它死循环在这

40:21

所以说这个测试的框架呢

40:22

并不会说是screen to visible

40:24

滚不到我就一直滚一直滚一直滚对吧

40:26

这样的话出现一个死循环也是不好的

40:28

所以说那我们这个滚的太慢的时候呢

40:30

啊

40:30

他其实就滚那么几下之后

40:31

他说啊好像没有

40:32

于是呢就出了这个错误

40:34

所以呢说这么多呢

40:35

就是为了带大家看一下它的另一个参数啊

40:37

叫做max cross

40:39

最多滚动50下

40:40

可以看到呢它是一个命名的参数

40:42

所以我们可以写max cross

40:43

比如说我们让它最多可以滚动4000下

40:46

最多滚动4000下的话呢

40:48

那这样的话就应该是能从那儿啊

40:50

4000下嘛

40:51

总共4000个逻辑像素应该是够的

40:53

所以呢就应该能滚动到了

40:54

好没有错

40:55

这样的我们测试呢就过了好

40:58

那么我们呢今天呢就是非常简单的

41:01

带大家看了一下啊

41:02

这个flutter里面呢只要写widget test对吧

41:05

首先呢我们学会了各种各样的fight的方法

41:07

包括什么by icon by text

41:09

by dji by type

41:10

后来呢我们在真正使用中发现by type和tt

41:13

这两种方法呢可能是最常用的

41:15

也是最方便的啊

41:16

同样的我们也看到了一些wii with text这种方法

41:19

比如说我想找到这个包含item 19这个字样的

41:21

这个list tile对吧

41:23

我就可以说我的text list tile

41:24

同时需要包含item 19对吧

41:27

那这个应该是能过的好

41:28

然后呢除了这些之外呢

41:29

我们还看到了啊

41:30

他那个ancestor

41:32

ancestor找到他的祖先

41:34

要找到descended对吧

41:35

然后呢之后呢我们还看了一些啊

41:37

expect expect呢

41:38

finds nothing和find one vision呢通常就已经是蛮不错的

41:41

expect了

41:42

同样的呢我们还看到了啊

41:44

可以用test.vision的方法去expect它更多的内容

41:47

对吧

41:48

test点位整方法呢

41:49

可以把其中一种你找到了这个final的

41:52

把它cast成你要的位置

41:53

比如说container啊

41:54

这边呢需要把这个container finer放他好

41:57

一旦给了他finder之后呢

41:58

你就可以去调用container的各种各样的属性

42:00

比如说去检查它的颜色之类的啊

42:02

你也可以通过test.get size

42:04

也是同样传给他一个finder之后呢

42:06

你就可以得到它渲染之后的尺寸

42:08

可以去看他的with height啊

42:10

这都是我们讲过的对吧

42:11

然后呢我们还讲了tedm punk

42:13

pump呢是会打出一针

42:15

然后呢pump frames是会对着一个target

42:18

注意这个target是个widget

42:19

所以呢可以给widget起个名字

42:21

给个变量名

42:22

对这个位置呢打出这么多时长中能打出几针

42:25

就打出几针

42:25

比如说1000ms转给他1000ms

42:27

它就会打出60几帧对吧

42:29

这是pump friends啊

42:30

然后呢还有一种更好用的是pump and settle

42:33

就是呢他会一直打出啊

42:34

下一针一直打到他没有下一针

42:36

没必要再打出下一帧为止

42:38

就是旁白and settle

42:39

对吧啊

42:40

最后呢我们看了一下这个test的交互啊

42:42

我们要看啊test.tab是吧

42:45

就可以单击

42:45

然后我们还看了test.enter text啊

42:48

可以输入一个文字啊

42:50

然后我们还看了test.drag

42:52

可以对一个final进行一个offset的拖对吧

42:55

拖拽操作

42:56

然后呢最后呢我们还看到了test.score

42:59

until visible

42:59

只在这个list view之类的测试中

43:01

比较常见的一些东西

43:03

希望这期教程呢能给你带来一些收获
